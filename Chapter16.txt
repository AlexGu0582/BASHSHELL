Script Control

Signaling the bash Shell

Signal  Value       Description
1       SIGHUP      Hangs up the process
2       SIGINT      Interrupts the process 
3       SIGQUIT     Stop the process 
9       SIGKILL     Unconditionally terminates the process 
15      SIGTERM     Terminates the process if possible
17      SIGSTOP     Unconditionally stops, but does not terminate, the process
18      SIGTSTP     Stops or pauses the process, but does not terminate 
19      SIGCONT     Continutes a stopped process 



The "Ctrl+C" key combination send a SIGINT signal.

The "Ctrl+Z" key combination send a SIGTSTP signal.


Trapping signals
trap commands signals 

test1.Sh 
#!/bin/bash 
#Testing signal trapping 
#
trap "echo ' Sorry, I have trapped Ctrl+C'" SIGINT 
#
echo "This is a test script"
#
count=1
while [ $count -le 10 ]
do 
    echo "Loop #$count"
    sleep 1
    count=$[ $count + 1 ]
done 
#
echo "This is the end of the test script."
#


Removing a trap 
test3b.sh 
#!/bin/bash 
#Removing a set trap 
#
trap "echo '  Sorry... Ctrl+C is trapped.'" SIGINT 
#
count=1
while [ $count -le 5 ]
do 
    echo "Loop $count"
    sleep 1
    count=$[ $count + 1 ]
done 
#
#Removing the trap 
trap -- SIGINT 
echo "I just removed the trap."
#
count=1
while [ $count + 1 ]
do 
    echo "Second Loop #$count"
    sleep 1
    count=$[ $count + 1 ]
done 
#


Running in the background
#When you place the ampersand symbol (&) after a command, it seperates the command from the bash shell and runs it as a separate background process on the system.
$./filename.sh &
[1] 3231
#The number in the square brackets is the job number assigned by the bash shell to the background process.


Viewing jobs

$jobs
[1]+ Stopped ./test10.sh
[2]- Running ./test10.sh > test10.out &

The "jobs" Command Parameters
Parameter   Description 
-l          Lists the PID of the process along with the job number 
-r          Lists only the running jobs
-s          Lists only stopped jobs 

$ jobs -l
[1] 1950 Running ./test10.sh > test10a.out &
[2]- 1952 Running ./test10.sh > test10b.out &
[3]+ 1955 Running ./test10.sh > test10c.out &
#"+" means the last one that was added to jobs list 
#"-" means the one next to the last one that was added to jobs list 


Restarting stopped jobs 
$bg 
[1]+ ./test11.sh &

$bg 2
[2]+ ./test12.sh &


Scheduling a job using the at command 
at -M [ -f filename ] time 
#-f option tells what script file to use and the now time designation directs "at" to run the scroipt immediately.
#-M option to suppress any output generated by jobs 

$ at -M -f test13b.sh tomorrow
job 18 at 2015-07-15 13:03


Removing jobs 

atrm number 


Scheduling regular scripts
corn 

The format for the cron table is :
min hour dayofmonth month dayofweek command 



#This checks every day at 12 noon to see if it's the last day of the month, and if so, cron runs the command.
00 12 * * * if [ `date +%d -d tomorrow` = 01 ] ; then ; command ; fi 

Create or Edit Crontab File 
$crontab -e 

To schedule a job for a different user, add the -u option and the username
$crontab -u [username] -e 


To list/check an existing cron table, use the -l parameter:
$crontab -l 

Using Operators
An asterisk (*) substitutes all possible values for a time field. For example, when used in the day field, it indicates that the task should be executed every day.
An asterisk (*) substitutes all possible values for a time field. For example, when used in the day field, it indicates that the task should be executed every day.
A dash (-) defines a range of values in a single field. Entering 15-18 in the minute field instructs Cron to run a task every minute between and including the 15th and 18th minute.
A forward slash (/) divides a field value into increments. For example, */30 in the minute field means that the task is run every 30 minutes.


Cron job on Linux: Examples

Run Cron job                    Command 
Every Minute                    * * * * * /path/to/script 
Every 15 minutes                */15 * * * * * * * * * /path/to/script 
On the 30th Minute of Everup    30 * * * * /path/to/script
Every 15 Minutes	            */15 * * * * /path/to/script
On the 30th Minute of Every Hour	30 * * * * /path/to/script
At the Beginning of Every Hour	0 * * * * /path/to/script
Every Day at Midnight	0 0 * * * /path/to/script
At 2 AM Every Day	0 2 * * * /path/to/script
Every 1st of the Month	0 0 1 * * /path/to/script
Every 15th of the Month	0 0 15 * * /path/to/script
On December 1st - Midnight	0 0 1 12 * /path/to/script
Saturdays at Midnight	0 0 * * 6 /path/to/script
Every Weekday at 4 AM	0 4 * * 1-5 /path/to/script
At 4 AM on Tuesdays and Thursdays	0 4 * * 2,4 /path/to/script
Every Other Day at 37 Minutes Past the Hour	37 1-23/2 * * * /path/to/script
Every 20 Minutes - Multiple Scripts	*/20 * * * * /path/to/script1; /path/to/script2
On Saturdays and Sundays at 12 PM	0 12 * * 6,0 /path/to/script
Monday to Friday - Every Hour 9 AM to 5 PM	0 9-17 * * 1-5 /path/to/script
Every Hour from 5 PM on Wednesday to 5 AM on Thursday (Job Spans Two Days)	0 17-23 * * 3 /path/to/script
0 0-5 * * 4 /path/to/script
Midnight Every Day - Send Output to a Different File	0 0 * * * /path/to/script > /path/to/output.log 2>&1